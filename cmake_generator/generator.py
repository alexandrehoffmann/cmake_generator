#!/usr/bin/env python3
"""
CMake Generator - Generate CMakeLists.txt from YAML configuration
"""

import yaml
from typing import Dict, List, Any, Optional


class CMakeGenerator:
    """Generate CMakeLists.txt from YAML configuration"""

    def __init__(self, config: Dict[str, Any]):
        """
        Initialize the generator with a configuration dictionary
        
        Args:
            config: Configuration dictionary parsed from YAML
        """
        self.config = config

    @classmethod
    def from_yaml(cls, yaml_path: str) -> "CMakeGenerator":
        """
        Create a generator from a YAML file
        
        Args:
            yaml_path: Path to the YAML configuration file
            
        Returns:
            CMakeGenerator instance
        """
        with open(yaml_path, 'r') as f:
            config = yaml.safe_load(f)
        return cls(config)

    def generate(self) -> str:
        """
        Generate CMakeLists.txt content
        
        Returns:
            Generated CMakeLists.txt content as a string
        """
        lines = []
        
        # Add header comment
        lines.append("# Generated by cmake_generator")
        lines.append("")
        
        # CMake minimum version
        cmake_min = self.config.get('project', {}).get('cmake_minimum', '3.15')
        lines.append(f"cmake_minimum_required(VERSION {cmake_min})")
        lines.append("")
        
        # Project declaration
        project = self.config.get('project', {})
        if project:
            lines.extend(self._generate_project(project))
            lines.append("")
        
        # C++ standard and compiler settings
        compiler = self.config.get('compiler', {})
        if compiler:
            lines.extend(self._generate_compiler_settings(compiler))
            lines.append("")
        
        # Dependencies
        dependencies = self.config.get('dependencies', [])
        if dependencies:
            lines.extend(self._generate_dependencies(dependencies))
            lines.append("")
        
        # Source files configuration
        sources = self.config.get('sources', {})
        if sources:
            lines.extend(self._generate_sources(sources))
            lines.append("")
        
        # Targets (executables and libraries)
        targets = self.config.get('targets', [])
        if targets:
            lines.extend(self._generate_targets(targets))
            lines.append("")
        
        # Installation rules
        install = self.config.get('install', {})
        if install:
            lines.extend(self._generate_install(install))
            lines.append("")
        
        return '\n'.join(lines)

    def _generate_project(self, project: Dict[str, Any]) -> List[str]:
        """Generate project declaration"""
        lines = []
        
        name = project.get('name', 'MyProject')
        version = project.get('version', '1.0.0')
        description = project.get('description', '')
        languages = project.get('languages', ['CXX'])
        
        if isinstance(languages, list):
            languages_str = ' '.join(languages)
        else:
            languages_str = languages
        
        lines.append(f"project({name}")
        lines.append(f"    VERSION {version}")
        if description:
            lines.append(f"    DESCRIPTION \"{description}\"")
        lines.append(f"    LANGUAGES {languages_str}")
        lines.append(")")
        
        return lines

    def _generate_compiler_settings(self, compiler: Dict[str, Any]) -> List[str]:
        """Generate compiler settings"""
        lines = []
        
        # C++ standard
        cpp_standard = compiler.get('cpp_standard')
        if cpp_standard:
            lines.append(f"set(CMAKE_CXX_STANDARD {cpp_standard})")
            lines.append("set(CMAKE_CXX_STANDARD_REQUIRED ON)")
            lines.append("set(CMAKE_CXX_EXTENSIONS OFF)")
        
        # Compiler flags
        flags = compiler.get('flags')
        if flags:
            if isinstance(flags, list):
                flags_str = ' '.join(flags)
            else:
                flags_str = flags
            lines.append(f"set(CMAKE_CXX_FLAGS \"${{CMAKE_CXX_FLAGS}} {flags_str}\")")
        
        # Warning levels
        warnings = compiler.get('warnings')
        if warnings:
            if warnings == 'extra':
                lines.append("if(MSVC)")
                lines.append("    add_compile_options(/W4)")
                lines.append("else()")
                lines.append("    add_compile_options(-Wall -Wextra -Wpedantic)")
                lines.append("endif()")
        
        return lines

    def _generate_dependencies(self, dependencies: List[Dict[str, Any]]) -> List[str]:
        """Generate dependency declarations"""
        lines = []
        lines.append("# Dependencies")
        
        for dep in dependencies:
            name = dep.get('name')
            version = dep.get('version')
            components = dep.get('components', [])
            required = dep.get('required', True)
            
            if not name:
                continue
            
            find_args = [name]
            
            if version:
                find_args.append(version)
            
            if not required:
                find_args.append("QUIET")
            
            if components:
                find_args.append("COMPONENTS")
                if isinstance(components, list):
                    find_args.extend(components)
                else:
                    find_args.append(components)
            
            lines.append(f"find_package({' '.join(find_args)})")
        
        return lines

    def _generate_sources(self, sources: Dict[str, Any]) -> List[str]:
        """Generate source file collection"""
        lines = []
        
        src_dir = sources.get('src_dir', 'src')
        include_dir = sources.get('include_dir', 'include')
        patterns = sources.get('patterns', ['*.cpp', '*.hpp'])
        
        if not isinstance(patterns, list):
            patterns = [patterns]
        
        # Collect source files
        lines.append("# Source files")
        for pattern in patterns:
            if pattern.endswith('.cpp') or pattern.endswith('.c') or pattern.endswith('.cc'):
                lines.append(f"file(GLOB_RECURSE SOURCES \"{src_dir}/{pattern}\")")
        
        # Include directories
        if include_dir:
            lines.append(f"include_directories({include_dir})")
        
        return lines

    def _generate_targets(self, targets: List[Dict[str, Any]]) -> List[str]:
        """Generate target definitions"""
        lines = []
        
        for target in targets:
            name = target.get('name')
            target_type = target.get('type', 'executable')
            sources = target.get('sources', [])
            dependencies = target.get('dependencies', [])
            include_dirs = target.get('include_dirs', [])
            compile_options = target.get('compile_options', [])
            cpp_standard = target.get('cpp_standard')
            
            if not name:
                continue
            
            lines.append(f"# Target: {name}")
            
            # Create target
            if isinstance(sources, list):
                sources_str = ' '.join(sources)
            else:
                sources_str = sources
            
            if target_type == 'executable':
                lines.append(f"add_executable({name} {sources_str})")
            elif target_type == 'library':
                lib_type = target.get('library_type', 'STATIC').upper()
                lines.append(f"add_library({name} {lib_type} {sources_str})")
            
            # C++ standard for this target
            if cpp_standard:
                lines.append(f"set_property(TARGET {name} PROPERTY CXX_STANDARD {cpp_standard})")
            
            # Link dependencies
            if dependencies:
                if isinstance(dependencies, list):
                    deps_str = ' '.join(dependencies)
                else:
                    deps_str = dependencies
                lines.append(f"target_link_libraries({name} PRIVATE {deps_str})")
            
            # Include directories
            if include_dirs:
                if isinstance(include_dirs, list):
                    for inc_dir in include_dirs:
                        lines.append(f"target_include_directories({name} PRIVATE {inc_dir})")
                else:
                    lines.append(f"target_include_directories({name} PRIVATE {include_dirs})")
            
            # Compile options
            if compile_options:
                if isinstance(compile_options, list):
                    opts_str = ' '.join(compile_options)
                else:
                    opts_str = compile_options
                lines.append(f"target_compile_options({name} PRIVATE {opts_str})")
            
            lines.append("")
        
        return lines

    def _generate_install(self, install: Dict[str, Any]) -> List[str]:
        """Generate installation rules"""
        lines = []
        lines.append("# Installation")
        
        targets = install.get('targets', [])
        headers_dir = install.get('headers_dir')
        destination = install.get('destination', 'bin')
        
        if targets:
            if isinstance(targets, list):
                targets_str = ' '.join(targets)
            else:
                targets_str = targets
            lines.append(f"install(TARGETS {targets_str} DESTINATION {destination})")
        
        if headers_dir:
            lines.append(f"install(DIRECTORY {headers_dir}/ DESTINATION include)")
        
        return lines

    def write_to_file(self, output_path: str = "CMakeLists.txt"):
        """
        Write generated CMakeLists.txt to a file
        
        Args:
            output_path: Path where to write the CMakeLists.txt file
        """
        content = self.generate()
        with open(output_path, 'w') as f:
            f.write(content)
